(defn slurp-or
  [path alt]
  (try
    (slurp path)
    (catch Error e
      alt)))

(def exit-code 0)

(defn have-option
  "Quick and dirty options parser."
  [opt]
  (some #(= opt %) *command-line-args*))

(def verbose (or (have-option "--verbose")
                 (have-option "-v")
                 (not (have-option "--no-verbose"))))

(let [test-dirs (->> (joker.os/ls "tests/eval")
                     (filter :dir?)
                     (map :name)
                     (remove #(joker.string/starts-with? % ".")))
      pwd (get (joker.os/env) "PWD")
      exe (str pwd "/joker")]
  (doseq [test-dir test-dirs]
    (when verbose
      (println (str "Running subtest " test-dir)))
    (let [dir (str "tests/eval/" test-dir "/")
          filename "input.joke"
          res (joker.os/sh-from dir exe filename) ; Someday add: :in "input.txt" (no :in support yet)
          out (:out res)
          err (:err res)
          rc (:exit res)
          expected-out (slurp-or (str dir "stdout.txt") "")
          expected-err (slurp-or (str dir "stderr.txt") "")
          expected-rc (if-let [rc (slurp-or (str dir "rc.txt") false)]
                        (int (bigint (with-in-str rc (read-line))))
                        0)]
      (when-not (and (= expected-out out) (= expected-err err) (= expected-rc rc))
        (println "FAILED:" test-dir)
        (when-not (= expected-out out)
          (println "EXPECTED STDOUT:")
          (println expected-out)
          (println "ACTUAL STDOUT:")
          (println out))
        (when-not (= expected-err err)
          (println "EXPECTED STDERR:")
          (println expected-err)
          (println "ACTUAL STDERR:")
          (println err))
        (when-not (= expected-rc rc)
          (println "EXPECTED RC:" expected-rc)
          (println "ACTUAL RC:" rc))
        (var-set #'exit-code 1)))))


(use '[joker.template])
(use '[joker.test])

;; even? odd?

(deftest test-even?
  (is (even? 2))
  (are [x] (true? x)
    (even? -4)
    (not (even? -3))
    (even? 0)
    (not (even? 5))
    (even? 8))
  (is (thrown? Error (even? 1/2))) ; was: thrown? IllegalArgumentException
  (is (thrown? Error (even? (double 10))))) ; was: thrown? IllegalArgumentException

(deftest test-odd?
  (are [x] (true? x)
    (not (odd? -4))
    (odd? -3)
    (not (odd? 0))
    (odd? 5)
    (odd? 6) ; TODO: Remove after confirming failures caught
    (not (odd? 8)))
  (is (thrown? Error (odd? 1/2))) ; was: thrown? IllegalArgumentException
  (is (thrown? Error (odd? (double 10))))) ; was: thrown? IllegalArgumentException

(let [res (run-all-tests)]
  (when (< 0 (+ (:fail res) (:error res)))
    (println "There were failures and/or errors; returning exit code 1")
    (var-set #'exit-code 1)))

(joker.os/exit exit-code)
