
(def joker-interns (set '(into instance? partial throw-if symbol empty second coll? sort-by some-> re-pattern val ns-unmap take-while ns-unalias min spread reset-meta! / assert-args condp bit-xor list? *loading-verbosely* loaded-libs select-keys with-in-str -> list* declare eval find *assert* split-at identical? cons__ filterv filter *e identity subvec bigfloat dec ratio? as-> bit-shift-right max__ nth subtract'__ pos__ fn inc__ multiply__ add__ - map? ==__ the-ns dec__ *loaded-libs* bigint some? bit-not denominator *in* update drop-last *ns* char? true? numerator interleave conj dec' *file* reduce-kv update-in seq__ count__ rest__ assert last concat with-meta__ cast__ keys frequencies first__ < assoc__ destructure re-seq replace-bindings split-with when-some hash-map__ fn? some bit-clear* bit-shift-left* neg__ unsigned-bit-shift-right* bit-and* bit-xor* bit-flip* distinct rem* bit-test create-ns ns-interns max-key zero? -' ns-aliases* bit-and-not find-ns* ns-name* keyword? remove-ns* number? refer* ns-unmap* var-get* next even? ns-resolve* keyword__ mapv force__ <__ doall *pending-paths* array-map int__ symbol__ >__ special-symbol? lazy-seq__ dissoc in-ns compare__ repeat re-matches with-redefs-fn eval* find-var* doseq num* set inc' vals* when-first contains?* ->> disj *' macroexpand-1 find* dissoc* unsigned-bit-shift-right name* rest ex-info* alter-meta__ = char swap* peek sigs re-find* bound? intern* deref rand-int alias atom* dorun associative? regex* xml-seq special-symbol?* prn nthrest *1 seq bigfloat? intern bit-set for int mapcat macroexpand-1* double* bigfloat* denominator* read* dotimes var-set boolean* with-out-str vector? take newline* read-string* with-redefs zipmap iterate not tree-seq load-lib re-find load-file* when test bound?* shuffle* libspec? nfirst lib-path* add-doc-and-meta reset-meta__ num println alter-meta! load-all quot slurp* hash* ns-name lazy-seq not-every? reset! memoize pos? and dedupe replace require get-in bit-shift-left *2 set? newline +' keep-indexed var? hash-map *linter-mode* *print-readably* interpose remove not-any? ns-map symbol? nil? distinct? defn- or comp cond-> hash-set flush str filter-key == cond key some->> list subs binding integer? slurp get range let rand some-fn ex-data inc force list__ not= not-empty defonce ns-aliases string? pop atom apply loop defmacro inc'__ load-string take-nth min__ multiply'__ keyword add'__ check-cyclic-dependency subtract__ divide__ >=__ dec'__ printf bit-flip * var-get if-let bit-or double public? *err* *out* sequential? >= time map-indexed with-bindings* read-string every-pred sort type hash cast *command-line-args* flatten pr with-bindings delay subvec__ prependss =__ hash-set__ rem next__ maybe-destructured refer neg? constantly instance?__ partition load conj__ meta__ cycle shuffle if-some vec__ ns-refers every? compare partition-by group-by vector vals *flush-on-newline* run! bit-or* bit-test* bit-set* bit-not* with-meta rseq reduce bit-and-not* spit bit-shift-right* sequence rand-nth peek* quot__ butlast ns-map* ns-unalias* alias* print cond->> all-ns* var-ns* var-set* find-ns println-str when-let take-last array-map* while > create-ns* defn lazy-cat *3 all-ns <=__ gensym__ random-sample fake-var identical__ nth__ + find-var str__ delay__ apply__ zero?__ reverse meta keys* when-not seq? nthnext contains? gensym ns-publics rseq__ type* sort* rational? mod pop* false? disj* namespace* counted? get* reductions macroexpand delay? realized? map boolean trampoline fnext print-str rand* default-data-readers pr-str prn-str swap! ns subs* reset* deref* format buffer* re-seq__ set-meta__ if-not count ex-data* reversible? comment vary-meta juxt assoc complement nnext vec keep assoc-in load-file resolve repeatedly remove-ns ns-resolve read-line* char* load-string* empty? fnil bit-and bigint__ case flush* merge-with numerator* drop-while pr* assert-valid-fdecl merge nano-time* ffirst callable? read drop name index-of* ex-info reduce-kv* namespace format* realized?* spit* empty* <= chunked-seq? first use load-one read-line max float? partition-all min-key odd? bit-clear cons load-libs)))

(defn arg-decls
  [arglists]
  (if (= 1 (count arglists))
    (str (first arglists))
    (clojure.string/join " " (map #(str "(" % ")") arglists))))

(defn decls
  [[sym v]]
  (let [m (meta v)
        arglists (:arglists m)]
    (when (and (not (clojure.string/starts-with? (str sym) "-"))
               (not (joker-interns sym))
               (seq arglists))
      (str "(defn " sym " " (arg-decls arglists) ")"))))

(println (clojure.string/join "\n" (keep decls (ns-interns 'cljs.core))))
