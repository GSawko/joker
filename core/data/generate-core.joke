;;; (set-macro__ ...)
;;; (defonce ...)
;;; (defn- ...) (metadata only?)
;;; (add-doc-and-meta ...) (probably okay, but what about preexisting symbols like *in*?)

(require '[joker.string :as s])

(def rpl s/replace)

(defn debug
  [& args]
  (when ((joker.os/env) "JOKER_DEBUG_CORE")
    (apply println args)))

;;; Discover namespaces dynamically by finding *.joke files that map
;;; to loadable namespaces.
(def namespaces
  (vec (->> (joker.os/ls ".")
            (remove :dir?)
            (map :name)
            (filter #(s/ends-with? % ".joke"))
            (map #(rpl % #"[.]joke$" ""))
            (map #(rpl % "_" "."))
            (map #(str "joker." %))
            (map symbol)
            (filter #(try (require %) true (catch Error e nil)))
            )))

(debug "Namespaces:" namespaces)

(def fn-template
  (slurp "fn.tmpl"))

(def package-template
  (slurp "package.tmpl"))

(def intern-template
  (slurp "intern.tmpl"))

(def addmeta-template
  (s/trim-right (slurp "addmeta.tmpl")))

(defn q
  [s]
  (str "\"" s "\""))

(defn raw-quoted-string
  "Returns a Go-style backtick-quoted string with backticks handled by appending double-quoted backticks"
  [^String s]
  (str "`" (rpl s "`" "` + \"`\" + `") "`"))

(defn go-name
  "Convert Clojure-style function name to unique Go-style name suitable as its internal implementation."
  [fn-name]
  (let [n (-> fn-name
              (rpl "-" "_minus_")
              (rpl "?" "")
              (rpl "*" "_star_")
              (rpl "<" "_lt_")
              (rpl ">" "_gt_")
              (rpl "=" "_eq_")
              (rpl "'" "_apos_")
              (rpl "+" "_plus_")
              (rpl "/" "_slash_")
              (str "_"))]
    (if (s/ends-with? fn-name "?")
      (str "is" n)
      n)))

(defn ^:private type-name
  [tag]
  (if (vector? tag)
    (str (first tag) "Vector")
    (str tag)))

(defn generate-arglist
  [args]
  (str "NewVectorFrom("
       (s/join ", " (for [arg args]
                      (str "MakeSymbol(" (q (str arg)) ")")))
       ")"))

(defn make-value
  "Returns code to make the Joker object representing the given value.

  E.g. 'String{S: \"value\"}'. Except for integers, the values are treated as strings (for now)."
  [v]
  (condp = (str (type v))
    "Int" (str "Int{I: " v "}")
    (str "String{S: " (q v) "}")))

(defn add-other-meta
  "Append meta tags other than what are normally present or irrelevant (:go)."
  [m]
  (let [m (dissoc m :doc :added :arglists :ns :name :file :line :column :go)]
    (s/join "" (map #(-> addmeta-template
                    (rpl "{key}" (s/replace-first (str (key %)) ":" ""))
                    (rpl "{value}" (make-value (val %)))) m))))

(defn generate-fn-decl
  [ns-name ns-name-final k v]
  (let [m (meta v)
        arglists (:arglists m)
        go-fn-name (go-name (str k))
        fn-str (-> fn-template
                   (rpl "{fnName}" go-fn-name))
        intern-str (-> intern-template
                       (rpl "{nsFullName}" ns-name)
                       (rpl "{nsName}" ns-name-final)
                       (rpl "{fnName}" (str k))
                       (rpl "{goName}" go-fn-name)
                       (rpl "{fnDocstring}" (if-let [d (:doc m)] (raw-quoted-string d) ""))
                       (rpl "{added}" (if-let [a (:added m)] a ""))
                       (rpl "{moreMeta}" (add-other-meta m))
                       (rpl "{args}"
                            (str "NewListFrom("
                                 (s/join ", " (for [args arglists]
                                                (generate-arglist args)))
                                 ")")))]
    [fn-str intern-str]))

(defn generate-fn-init
  [v]
  (let [g (go-name (str v))]
    (format "\t%s = __%s" g g)))

(defn go-data-type
  "Returns the type of the object."
  [obj]
  "Object")

(defn generate-const-or-var-decl
  [name m]
  (format "var %s %s" name (go-data-type name)))

(defn generate-const-or-var-init
  [name m]
  (let [type (type-name (:tag m))]
    (format "\t%s = Make%s(%s)"
            name
            type
            (:go m))))

(defn generate-non-fn-decl
  [ns-name ns-name-final k v]
  (debug "ns-name=" ns-name " ns-name-final=" ns-name-final " k=" k " v=" v)
  (let [m (meta v)
        go-non-fn-name (go-name (str k))
        non-fn-str (generate-const-or-var-decl go-non-fn-name m)
        intern-str (-> intern-template
                       (rpl "{nsFullName}" ns-name)
                       (rpl "{nsName}" ns-name-final)
                       (rpl "{fnName}" (str k))
                       (rpl "{goName}" go-non-fn-name)
                       (rpl "{fnDocstring}" (if-let [d (:doc m)] (raw-quoted-string d) ""))
                       (rpl "{added}" (if-let [a (:added m)] a ""))
                       (rpl "{moreMeta}" (add-other-meta m))
                       (rpl "{args}" "nil"))]
    [non-fn-str intern-str]))

(defn generate-non-fn-init
  [ns-name-final k v]
  (let [m (meta v)
        go-non-fn-name (go-name (str k))
        non-fn-str (generate-const-or-var-init go-non-fn-name m)]
    non-fn-str))

(defn comment-out
  [s]
  (-> s
      (rpl "\n// " "\n")
      (rpl "\n" "\n//")
      (rpl "\n// package" "\npackage")))

(defn compare-imports
  [^String l ^String r]
  (cond
    (s/starts-with? l ". ") (if (s/starts-with? r ". ")
                              (compare l r)
                              -1)
    (s/starts-with? r ". ") 1
    :else (compare l r)))

(defn ns-interned
  "Returns a map of the intern mappings for the namespace."
  {:added "1.0"}
  ^Map [ns]
  ;; TODO: types (Namespace or Symbol)
  (let [ns (the-ns ns)]
    (joker.core/filter-key val (fn [^Var v] (and (or true (instance? Var v))  ; TODO: Add back Var check?
                                                 (= ns (joker.core/var-ns__ v))))
                           (ns-map ns))))

(defn- ns-fns
  "Return only mappings that are functions."
  [ns]
  (remove #(:macro (meta (val %)))
          (filter #(:arglists (meta (val %))) (ns-interned ns))))

(defn- ns-non-fns
  "Return only mappings that are not functions."
  [ns]
  (remove #(:macro (meta (val %)))
          (remove #(:arglists (meta (val %))) (ns-interned ns))))

(defn generate-ns
  [ns-sym ns-name ns-name-final]
  (let [ns (find-ns ns-sym)
        m (meta ns)
        fns (sort-by first (ns-fns ns))
        non-fns (sort-by first (ns-non-fns ns))
        fn-decls (for [[k v] fns]
                   (generate-fn-decl ns-name ns-name-final k v))
        fn-inits (for [[k _] fns]
                   (generate-fn-init k))
        non-fn-decls (for [[k v] non-fns]
                       (generate-non-fn-decl ns-name ns-name-final k v))
        non-fn-inits (for [[k v] non-fns]
                       (generate-non-fn-init ns-name-final k v))
        res (-> package-template
                (rpl "{nsFullName}" ns-name)
                (rpl "{nsName}" ns-name-final)
                (rpl "{imports}"
                     (s/join "\n\t" (sort compare-imports (conj
                                                           []  ; TODO: any more imports needed?
                                                           ". \"github.com/candid82/joker/core\""))))
                (rpl "{non-fn-decls}" (s/join "\n" (map first non-fn-decls)))
                (rpl "{non-fn-inits}" (s/join "\n" non-fn-inits))
                (rpl "{fn-decls}" (s/join "\n" (map first fn-decls)))
                (rpl "{fn-inits}" (s/join "\n" fn-inits))
                (rpl "{nsDocstring}" (raw-quoted-string (:doc m)))
                (rpl "{non-fn-interns}" (s/join "\n\t" (map second non-fn-decls)))
                (rpl "{fn-interns}" (s/join "\n\t" (map second fn-decls))))
        res (if (:empty m)
              (comment-out res)
              res)]
    res))

(defn ns-file-name
  [dir ns-name-final]
  (str dir "/a_" ns-name-final ".go"))

(defn remove-blanky-lines
  [s]
  (-> s
      (rpl #"[[:space:]]*{blank}" "")))

(doseq [ns-sym namespaces]
  (let [ns-name (str ns-sym)
        dir (rpl ns-name "." "/")
        ns-name-final (rpl ns-name #".*[.]" "")]
    (spit (ns-file-name "." ns-name-final)
          (remove-blanky-lines (generate-ns ns-sym ns-name ns-name-final)))))
