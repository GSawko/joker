;;; (set-macro__ ...)
;;; (defonce ...)
;;; (defn- ...) (metadata only?)
;;; (add-doc-and-meta ...) (probably okay, but what about preexisting symbols like *in*?)

(require '[joker.string :as s])

(def rpl s/replace)

(defn debug
  [& args]
  (when ((joker.os/env) "JOKER_DEBUG_CORE")
    (apply println args)))

;;; Discover namespaces dynamically by finding *.joke files that map
;;; to loadable namespaces.
(def namespaces
  (vec (->> (joker.os/ls ".")
            (remove :dir?)
            (map :name)
            (filter #(s/ends-with? % ".joke"))
            (map #(rpl % #"[.]joke$" ""))
            (map #(rpl % "_" "."))
            (map #(str "joker." %))
            (map symbol)
            (filter #(try (require %) true (catch Error e nil)))
            )))

(debug "Namespaces:" namespaces)

(def fn-template
  (slurp "fn.tmpl"))

(def package-template
  (slurp "package.tmpl"))

(def intern-template
  (slurp "intern.tmpl"))

(def addmeta-template
  (s/trim-right (slurp "addmeta.tmpl")))

(defn q
  [s]
  (str "\"" s "\""))

(defn raw-quoted-string
  "Returns a Go-style backtick-quoted string with backticks handled by appending double-quoted backticks"
  [^String s]
  (str "`" (rpl s "`" "` + \"`\" + `") "`"))

(defn go-name
  "Convert Clojure-style name to unique Go-style name suitable as its internal implementation."
  [name]
  (let [n (-> name
              (rpl "-" "_minus_")
              (rpl "?" "")
              (rpl "*" "_star_")
              (rpl "<" "_lt_")
              (rpl ">" "_gt_")
              (rpl "=" "_eq_")
              (rpl "'" "_apos_")
              (rpl "+" "_plus_")
              (rpl "/" "_slash_")
              (rpl "!" "_bang_")
              (str "_"))]
    (if (s/ends-with? name "?")
      (str "is" n)
      n)))

(defn ^:private type-name
  [tag]
  (if (vector? tag)
    (str (first tag) "Vector")
    (str tag)))

(defn generate-arglist
  [args]
  (str "NewVectorFrom("
       (s/join ", " (for [arg args]
                      (str "MakeSymbol(" (q (str arg)) ")")))
       ")"))

(defn go-object-for
  [indent o]
  (condp = (type o)
    Boolean (str "Boolean{B: " o "}")
    Int (str "Int{I: " o "}")
    Keyword (str "MakeKeyword(" (q (name o)) ")")
    List (str "NewListFrom(\n" indent "\t" (s/join (str ",\n" indent "\t") (conj (mapv #(go-object-for (str indent "\t") %) o) ")")))
    Proc (let [p (rpl (str o) #".*:(.*)[]]" "$1")] (str "Proc{fn: " p ", name: " (q p) "}"))
    String (str "String{S: " (q o) "}")
    Symbol (str "MakeSymbol(" (q (name o)) ")")
    Vector (str "NewVectorFrom(\n" indent "\t" (s/join (str ",\n" indent "\t") (conj (mapv #(go-object-for (str indent "\t") %) o) ")")))
    (str "NIL /* " (str (type o)) " */")))

(defn add-other-meta
  "Append meta tags other than what are normally present or irrelevant (:go)."
  [m]
  (let [m (dissoc m :doc :added :ns :name)]
    (s/join "" (map #(-> addmeta-template
                    (rpl "{key}" (s/replace-first (str (key %)) ":" ""))
                    (rpl "{value}" (go-object-for "" (val %)))) m))))

(defn generate-decl
  [ns-name ns-name-final k v]
  (debug "ns-name=" ns-name " ns-name-final=" ns-name-final " k=" k " v=" v)
  (let [m (meta v)
        go-object-name (go-name (str k))
        go-init (str "var " go-object-name " = " (go-object-for "" (deref v)))
        intern-str (-> intern-template
                       (rpl "{nsFullName}" ns-name)
                       (rpl "{nsName}" ns-name-final)
                       (rpl "{varName}" (str k))
                       (rpl "{goObject}" go-object-name)
                       (rpl "{varDocstring}" (if-let [d (:doc m)] (raw-quoted-string d) "\"\""))
                       (rpl "{added}" (if-let [a (:added m)] a ""))
                       (rpl "{moreMeta}" (add-other-meta m))
                       (rpl "{args}" "nil"))]
    [go-init intern-str]))

(defn comment-out
  [s]
  (-> s
      (rpl "\n// " "\n")
      (rpl "\n" "\n//")
      (rpl "\n// package" "\npackage")))

(defn compare-imports
  [^String l ^String r]
  (cond
    (s/starts-with? l ". ") (if (s/starts-with? r ". ")
                              (compare l r)
                              -1)
    (s/starts-with? r ". ") 1
    :else (compare l r)))

(defn ns-interned
  "Returns a map of the intern mappings for the namespace."
  {:added "1.0"}
  ^Map [ns]
  ;; TODO: types (Namespace or Symbol)
  (let [ns (the-ns ns)]
    (joker.core/filter-key val (fn [^Var v] (and (or true (instance? Var v))  ; TODO: Add back Var check?
                                                 (= ns (joker.core/var-ns__ v))))
                           (ns-map ns))))

(defn ^String ns-info-name
  [^String ns]
  (-> ns
       (rpl "joker." "")
       (rpl "." "_")))

(defn generate-ns
  [ns-sym ns-name ns-name-final]
  (let [ns (find-ns ns-sym)
        m (meta ns)
        vars (sort-by first (ns-interned ns))
        decls (for [[k v] vars]
                (generate-decl ns-name ns-name-final k v))
        ;; inits (for [[k _] vars]
        ;;         (generate-init k))
        ns-info (ns-info-name ns-name)
        res (-> package-template
                (rpl "{nsFullName}" ns-name)
                (rpl "{nsName}" ns-name-final)
                (rpl "{nsInfoName}" ns-info)
                (rpl "{imports}"  ; Currently absent from template
                     (s/join "\n\t" (sort compare-imports (conj
                                                           []  ; TODO: any more imports needed?
                                                           ". \"github.com/candid82/joker/core\""))))
                (rpl "{decls}" (s/join "\n\n" (map first decls)))
                ;; (rpl "{inits}" (s/join "\n" inits))  ; Currently absent from template
                (rpl "{nsDocstring}" (raw-quoted-string (:doc m)))
                (rpl "{interns}" (s/join "\n\t" (map second decls))))
        res (if (:empty m)
              (comment-out res)
              res)]
    res))

(defn ns-file-name
  [dir ns-name-final]
  (str dir "/../a_" ns-name-final "_code.go"))

(defn remove-blanky-lines
  [s]
  (-> s
      (rpl #"[[:space:]]*{blank}" "")))

(doseq [ns-sym namespaces]
  (let [ns-name (str ns-sym)
        dir (rpl ns-name "." "/")
        ns-name-final (rpl ns-name #".*[.]" "")]
    (spit (ns-file-name "." ns-name-final)
          (remove-blanky-lines (generate-ns ns-sym ns-name ns-name-final)))))
